/*  
  В данном примере классы напрямую зависят друг от друга, что нарушает принцип инверсии зависимостей (D из SOLID). 
  Нарушение принципа может привести к проблемам при тестировании и рефакторинге.

  Для решения следует использовать инверсию и внедрение зависимостей.
  В данной реализации она не совсем "честная", так как я ссылаюсь на конкретные классы, а не определяю нужный интерфейс.
*/

class A {
  constructor(private b: B) {}

  getB() {
    return this.b
  }
}

class B {
  constructor(private c: C) {}

  getC() {
    return this.c
  }
}

class C {
  doSomething() {
    // Логика
  }
}

const c = new C()
const b = new B(c)
const a = new A(b)

// В текущем состоянии я бы оставил чейн, но при будущих изменениях можно сделать отдельные переменные для результата методов getB и getC
a.getB().getC().doSomething()
